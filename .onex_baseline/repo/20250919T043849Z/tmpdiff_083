diff --git a/tests/test_concurrency.py b/tests/test_concurrency.py
new file mode 100644
index 0000000..85d25b9
--- /dev/null
+++ b/tests/test_concurrency.py
@@ -0,0 +1,319 @@
+"""
+Tests for concurrency utilities following ONEX standards.
+"""
+
+from __future__ import annotations
+
+import asyncio
+import pytest
+from unittest.mock import Mock, AsyncMock, patch
+from uuid import uuid4
+
+from omnimemory.utils.concurrency import (
+    ConnectionPool,
+    CircuitBreaker,
+    CircuitBreakerState,
+    with_circuit_breaker,
+    with_timeout,
+    with_retry
+)
+
+
+class TestConnectionPool:
+    """Test connection pool functionality."""
+
+    @pytest.mark.asyncio
+    async def test_connection_pool_creation(self):
+        """Test connection pool can be created with valid parameters."""
+        pool = ConnectionPool(max_size=5, timeout=30.0)
+        assert pool.max_size == 5
+        assert pool.timeout == 30.0
+
+    @pytest.mark.asyncio
+    async def test_connection_pool_acquire_release(self):
+        """Test connection acquisition and release."""
+        pool = ConnectionPool(max_size=2, timeout=1.0)
+
+        # Mock connection factory
+        mock_conn = Mock()
+        pool._create_connection = Mock(return_value=mock_conn)
+
+        # Acquire connection
+        async with pool.acquire() as conn:
+            assert conn is mock_conn
+            assert pool.active_connections == 1
+
+        # Connection should be released
+        assert pool.active_connections == 0
+
+    @pytest.mark.asyncio
+    async def test_connection_pool_max_size_limit(self):
+        """Test connection pool respects max size limit."""
+        pool = ConnectionPool(max_size=1, timeout=0.1)
+        pool._create_connection = Mock(return_value=Mock())
+
+        # First connection should work
+        async with pool.acquire():
+            # Second connection should timeout
+            with pytest.raises(asyncio.TimeoutError):
+                async with pool.acquire():
+                    pass
+
+    @pytest.mark.asyncio
+    async def test_connection_pool_iterative_retry_prevents_recursion(self):
+        """Test that connection pool uses iterative retry to prevent stack overflow."""
+        pool = ConnectionPool(max_size=1, timeout=1.0)
+
+        # Mock connection factory that fails first few times
+        call_count = 0
+        def create_failing_connection():
+            nonlocal call_count
+            call_count += 1
+            if call_count <= 2:  # Fail first 2 attempts
+                raise ConnectionError("Connection failed")
+            return Mock()
+
+        pool._create_connection = create_failing_connection
+
+        # This should succeed on 3rd attempt using iterative retry
+        async with pool.acquire() as conn:
+            assert conn is not None
+            assert call_count == 3
+
+
+class TestCircuitBreaker:
+    """Test circuit breaker functionality."""
+
+    def test_circuit_breaker_creation(self):
+        """Test circuit breaker can be created with valid parameters."""
+        cb = CircuitBreaker(failure_threshold=3, recovery_timeout=60.0)
+        assert cb.failure_threshold == 3
+        assert cb.recovery_timeout == 60.0
+        assert cb.state == CircuitBreakerState.CLOSED
+
+    @pytest.mark.asyncio
+    async def test_circuit_breaker_success_flow(self):
+        """Test circuit breaker allows successful operations."""
+        cb = CircuitBreaker(failure_threshold=2)
+
+        @with_circuit_breaker(cb)
+        async def successful_operation():
+            return "success"
+
+        result = await successful_operation()
+        assert result == "success"
+        assert cb.success_count == 1
+        assert cb.failure_count == 0
+
+    @pytest.mark.asyncio
+    async def test_circuit_breaker_failure_threshold(self):
+        """Test circuit breaker opens after failure threshold."""
+        cb = CircuitBreaker(failure_threshold=2, recovery_timeout=0.1)
+
+        @with_circuit_breaker(cb)
+        async def failing_operation():
+            raise ValueError("Operation failed")
+
+        # First failure
+        with pytest.raises(ValueError):
+            await failing_operation()
+        assert cb.state == CircuitBreakerState.CLOSED
+
+        # Second failure - should open circuit
+        with pytest.raises(ValueError):
+            await failing_operation()
+        assert cb.state == CircuitBreakerState.OPEN
+
+        # Third call should be blocked
+        with pytest.raises(Exception):  # Circuit breaker exception
+            await failing_operation()
+
+    @pytest.mark.asyncio
+    async def test_circuit_breaker_half_open_recovery(self):
+        """Test circuit breaker recovery through half-open state."""
+        cb = CircuitBreaker(failure_threshold=1, recovery_timeout=0.1)
+
+        call_count = 0
+        @with_circuit_breaker(cb)
+        async def recovering_operation():
+            nonlocal call_count
+            call_count += 1
+            if call_count == 1:
+                raise ValueError("Initial failure")
+            return "recovered"
+
+        # Cause failure to open circuit
+        with pytest.raises(ValueError):
+            await recovering_operation()
+        assert cb.state == CircuitBreakerState.OPEN
+
+        # Wait for recovery timeout
+        await asyncio.sleep(0.2)
+
+        # Next call should succeed and close circuit
+        result = await recovering_operation()
+        assert result == "recovered"
+        assert cb.state == CircuitBreakerState.CLOSED
+
+
+class TestTimeoutDecorator:
+    """Test timeout decorator functionality."""
+
+    @pytest.mark.asyncio
+    async def test_with_timeout_success(self):
+        """Test timeout decorator allows fast operations."""
+        @with_timeout(1.0)
+        async def fast_operation():
+            await asyncio.sleep(0.1)
+            return "completed"
+
+        result = await fast_operation()
+        assert result == "completed"
+
+    @pytest.mark.asyncio
+    async def test_with_timeout_failure(self):
+        """Test timeout decorator cancels slow operations."""
+        @with_timeout(0.1)
+        async def slow_operation():
+            await asyncio.sleep(1.0)
+            return "should not complete"
+
+        with pytest.raises(asyncio.TimeoutError):
+            await slow_operation()
+
+
+class TestRetryDecorator:
+    """Test retry decorator functionality."""
+
+    @pytest.mark.asyncio
+    async def test_with_retry_success(self):
+        """Test retry decorator allows successful operations."""
+        @with_retry(max_attempts=3, delay=0.1)
+        async def successful_operation():
+            return "success"
+
+        result = await successful_operation()
+        assert result == "success"
+
+    @pytest.mark.asyncio
+    async def test_with_retry_eventual_success(self):
+        """Test retry decorator retries until success."""
+        call_count = 0
+
+        @with_retry(max_attempts=3, delay=0.01)
+        async def eventually_successful():
+            nonlocal call_count
+            call_count += 1
+            if call_count < 3:
+                raise ValueError(f"Attempt {call_count} failed")
+            return "success"
+
+        result = await eventually_successful()
+        assert result == "success"
+        assert call_count == 3
+
+    @pytest.mark.asyncio
+    async def test_with_retry_max_attempts_exceeded(self):
+        """Test retry decorator respects max attempts."""
+        call_count = 0
+
+        @with_retry(max_attempts=2, delay=0.01)
+        async def always_failing():
+            nonlocal call_count
+            call_count += 1
+            raise ValueError(f"Attempt {call_count} failed")
+
+        with pytest.raises(ValueError, match="Attempt 2 failed"):
+            await always_failing()
+        assert call_count == 2
+
+    @pytest.mark.asyncio
+    async def test_with_retry_exponential_backoff(self):
+        """Test retry decorator uses exponential backoff."""
+        call_times = []
+
+        @with_retry(max_attempts=3, delay=0.1, backoff_multiplier=2.0)
+        async def timing_operation():
+            call_times.append(asyncio.get_event_loop().time())
+            if len(call_times) < 3:
+                raise ValueError("Not yet")
+            return "success"
+
+        start_time = asyncio.get_event_loop().time()
+        await timing_operation()
+
+        # Check that delays increased exponentially
+        assert len(call_times) == 3
+        delay1 = call_times[1] - call_times[0]
+        delay2 = call_times[2] - call_times[1]
+
+        # Second delay should be roughly twice the first
+        assert 0.18 < delay2 < 0.22  # ~0.2s (0.1 * 2)
+        assert 0.08 < delay1 < 0.12   # ~0.1s
+
+
+@pytest.mark.integration
+class TestConcurrencyIntegration:
+    """Integration tests for concurrency utilities."""
+
+    @pytest.mark.asyncio
+    async def test_connection_pool_with_circuit_breaker(self):
+        """Test connection pool integrated with circuit breaker."""
+        pool = ConnectionPool(max_size=2, timeout=1.0)
+        cb = CircuitBreaker(failure_threshold=2, recovery_timeout=0.1)
+
+        # Mock connection that fails first few times
+        fail_count = 0
+        def create_connection():
+            nonlocal fail_count
+            fail_count += 1
+            if fail_count <= 2:
+                raise ConnectionError("Connection failed")
+            return Mock()
+
+        pool._create_connection = create_connection
+
+        @with_circuit_breaker(cb)
+        async def get_connection():
+            async with pool.acquire() as conn:
+                return conn
+
+        # First two attempts should fail
+        with pytest.raises(ConnectionError):
+            await get_connection()
+
+        with pytest.raises(ConnectionError):
+            await get_connection()
+
+        # Circuit should now be open
+        assert cb.state == CircuitBreakerState.OPEN
+
+        # Next attempt should be blocked by circuit breaker
+        with pytest.raises(Exception):
+            await get_connection()
+
+    @pytest.mark.asyncio
+    async def test_retry_with_timeout_and_circuit_breaker(self):
+        """Test retry combined with timeout and circuit breaker."""
+        cb = CircuitBreaker(failure_threshold=3, recovery_timeout=0.1)
+
+        attempt_count = 0
+
+        @with_timeout(0.5)
+        @with_retry(max_attempts=5, delay=0.05)
+        @with_circuit_breaker(cb)
+        async def complex_operation():
+            nonlocal attempt_count
+            attempt_count += 1
+
+            if attempt_count < 3:
+                raise ValueError(f"Attempt {attempt_count} failed")
+
+            await asyncio.sleep(0.02)  # Small delay
+            return f"Success on attempt {attempt_count}"
+
+        result = await complex_operation()
+        assert result == "Success on attempt 3"
+        assert attempt_count == 3
+        assert cb.state == CircuitBreakerState.CLOSED
+        assert cb.success_count == 1
\ No newline at end of file
